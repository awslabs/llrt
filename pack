#!/usr/bin/env bash
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

set -e

if [ "$#" -lt 2 ]; then
  echo "Error: Two file arguments are required."
  echo "Usage: $0 input_file output_file <additional file>"
  exit 1
fi


# Set the number of parts to split the file into
num_parts=2
data_size=$(wc -c < "$1")

srcfile="$1"
dstfile="$2"
additional_file="$3"
additional_file_dict="$4"

if [ ! -z "$additional_file" ] && [ ! -f "$additional_file" ]; then
    echo "Error: Additional file $additional_file does not exist."
    exit 1
fi

# Check if the bytes start with \x7fELF
if [[ $(hexdump -n 4 -e '4/1 "%02x"' $srcfile) != "7f454c46" ]]; then
    echo "The binary is not an ELF executable"
    exit 1
fi

arch_hex=$(hexdump -s 18 -n 1 -e '"%02x"' $srcfile)

if [[ "$arch_hex" == "3e" ]]; then
    target="x86_64-linux-musl"
    arch="x64"
elif [[ "$arch_hex" == "b7" ]]; then
    target="aarch64-linux-musl"
    arch="arm64"
else
    echo "The binary is not an ARM64 or X86_64 ELF executable"
    exit 1
fi

# Create a temporary directory to store the parts
temp_folder=$(mktemp -d)

# Split the file into parts and compress each part using zstd
split -n ${num_parts} $srcfile ${temp_folder}/part_


function to_u8le() {
    for num in "$@"; do
        printf "%02x" $num |  xxd -r -p
    done
}


function to_u32le() {
    for num in "$@"; do
        local le_hex=$(printf "%08x" $num | sed 's/\(..\)\(..\)\(..\)\(..\)/\4\3\2\1/')
        printf "$le_hex" | xxd -r -p
    done
}


function compress(){
    local src=$1
    local dst=$2
    local dict=$3

    local dict_args=""

    if [ ! -z "$dict" ]; then
        dict_args="-D ${dict}"
    fi

    zstd --ultra $dict_args -22 --no-check -f "$src" -o "${dst}"
}

compressed_file="${temp_folder}/compressed"

input_sizes=()
output_sizes=()
total_input_size=0
total_output_size=0
working_dir=$(pwd)

for file in ${temp_folder}/*; do
    touch $compressed_file
    filename=$(basename $file)
    echo "Compressing $filename..."
    (cd $(dirname $file) && compress "$filename" "${filename}.zst")
    output_size=$(wc -c < "${file}")
    input_size=$(wc -c < "${file}.zst")
    input_sizes+=($input_size)
    output_sizes+=($output_size)
    total_input_size=$((total_input_size + input_size))
    total_output_size=$((total_output_size + output_size))

    cat "${file}.zst" >> $compressed_file
    rm "${file}"
done


cp "$1" "${1}.bak"

echo "Compiling for $target..."

original_size=$(du -h $srcfile | cut -f1)

zig cc -target $target -Wno-null-character -std=c99 -Wall -O3 -flto -s llrt/src/main.c -o $dstfile -Ilib -Llib/${arch} -static -lzstd

dst_size=$(wc -c < "${dstfile}")


echo "Done. Appending compressed binary..."

to_u8le $num_parts >> "${dstfile}"
to_u32le ${input_sizes[@]} >> "${dstfile}"
to_u32le ${output_sizes[@]} >> "${dstfile}"
cat $compressed_file >> "${dstfile}"

if [ ! -z "$additional_file" ]; then
  echo  "Done. Appending additional data..."
  filename=$(basename $additional_file)
  additional_size=$(wc -c < "$additional_file")

  echo "Compressing $additional_size..."

  cp "$additional_file" "${temp_folder}/${filename}"
  if [ ! -z "$additional_file_dict" ]; then
    cp "$additional_file_dict" "${temp_folder}/${filename}.dict"
  fi
  (cd "${temp_folder}" && compress "${filename}" "${filename}.zst" "${filename}.dict")

  cat "${temp_folder}/${filename}.zst" >> "${dstfile}"

  to_u32le $additional_size >> "${dstfile}"
fi

to_u32le $dst_size >> "${dstfile}"

new_size=$(du -h $dstfile | cut -f1)

echo "Done. Compressed $original_size => $new_size"

rm -rf $temp_folder